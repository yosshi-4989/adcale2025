# 注意

このコマンドは結構簡単にブランチが壊れるので使う場合はしっかり理解した上でするか、
壊れてもいいように`rebase`用のブランチを切ってから作業をすることをお勧めします。
※というか`rebase`に限らずコンフリクトが発生する可能性のある作業はぶっ壊れてもいいように一時ブランチで作業してから本ブランチにマージするようにした方がいいです。

# `rebase`コマンド(コミット操作)概要(？)

`-i`オプションをつけることで指定したコミットから現在のコミットまでのコミット一覧が表示されて、
各コミットに対して様々な処理が可能になる。

例として以下のコミットを考える。  
※`git log --oneline`の結果

```git
a8377b4 (HEAD -> main) sample4
786a446 sample3
129ec2f sample2
9446330 sample1
```

この時に`git rebase -i 9446330`と実行するとエディタが起動して以下のように表示される。  
※自分で使うときは`git rebase -i HEAD^^^`で指定することが多いかな

```vim
pick 129ec2f sample2
pick 786a446 sample3
pick a8377b4 sample4

; Rebase 9446330..a8377b4 onto 9446330 (3 commands)
;
; Commands:
; p, pick <commit> = use commit
; r, reword <commit> = use commit, but edit the commit message
; e, edit <commit> = use commit, but stop for amending
; s, squash <commit> = use commit, but meld into previous commit
; f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
;                    commit's log message, unless -C is used, in which case
;                    keep only this commit's message; -c is same as -C but
;                    opens the editor
; x, exec <command> = run command (the rest of the line) using shell
; b, break = stop here (continue rebase later with 'git rebase --continue')
; d, drop <commit> = remove commit
; l, label <label> = label current HEAD with a name
; t, reset <label> = reset HEAD to a label
; m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
;         create a merge commit using the original merge commit's
;         message (or the oneline, if no original merge commit was
;         specified); use -c <commit> to reword the commit message
; u, update-ref <ref> = track a placeholder for the <ref> to be updated
;                       to this position in the new commits. The <ref> is
;                       updated at the end of the rebase
;
; These lines can be re-ordered; they are executed from top to bottom.
;
; If you remove a line here THAT COMMIT WILL BE LOST.
;
; However, if you remove everything, the rebase will be aborted.
;
```
※行頭の`;`は`01.md(config)`で`core.commentChar=';'`を設定しているため。

`<command> <commit_number> <commit_message>`の形式で表示されるので、
各コミットに対してコマンドを指定することができる。  
コマンドの内容は記載されているが、自分がよく使うものについて以下に記載する。

|command|概要|
|---|---|
|p/pick|そのまま。デフォルトで指定されてる|
|r/reword|コミットメッセージの変更|
|e/edit|そのコミットのdiffをエディタを開いて編集する|
|s/squash|一つ前のコミットに取り込む。その際、合算したコミットメッセージを元にコミットメッセージの変更も行う。|

そして、最も重要な点として、コマンドの説明の後に記載されている、  
　`These lines can be re-ordered;`  
つまり、コミットの入れ替えが可能である点にある。

例えば上記の3コミットに対して以下のように設定すると、

```
pick 129ec2f sample2
s a8377b4 sample4
pick 786a446 sample3
```

`sampel2`と`sample4`のコミットをまとめて一つのコミットを作成し、
そのあとに`sample3`のコミットをつなぐ、という処理ができる。

当然、コミットの入れ替えを行うと、`sample3`で行った修正を`sample4`でさらに修正してるなどで存在しないコードへの修正が発生してコンフリクトが発生する。  
それを理解した上で、開発するときは機能やファイルなどで細かく修正をコミットしていくことで、
開発が終了した時点で`rebase`コマンドでコミットをまとめたり、実装→テストなどのようにコミットの順番を綺麗にすることができる。
そして、前節の`develop`ブランチから`rebase`するケースなどで、コンフリクトが発生する場合に、コミットをまとめておくことでコンフリクトの解消する回数を減らすこともできる！

なお、注意点として前節の`rebase`コマンドと同様に、コミット番号が新しく振られたり、rebase中のコンフリクトはコンフリクト解消用のモードになったりするなどを意識しておくこと。

# よく使うオプション

## -i, --interactive

上記参照。

# その他オプション

# コメント

マジで便利。大好き。  
開発中に、WIP(Work In Progress)でコミットしておいて後で綺麗に直そう、ができるので検証中とかは特に、
修正の履歴を気軽に残して改修がダメそうだったら「この時の実装を復元しよう」が気軽にできたりもする。  
間違って編集内容を消してしまう事故とかも、コミットとして残しておけば回避出来たりもするので、雑にコミットを残せるメリットは計り知れない。(まぁ、やろうと思えば別途ブランチを切って開発が終わったら`feature`ブランチでrestoreしてコミットをする、で同じことができるけど)
必要に応じて`reset`と併用してあげるとさらに自由にコミットの整理ができるけど、まぁこれはコミットの作り方ミスったときのリカバリ用かな。

本当は実際に操作した話とかしたかったけど、流石に面倒だったのでとりあえずはこれでいいや。
